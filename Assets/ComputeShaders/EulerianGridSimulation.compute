// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel InitialiseGrid
#pragma kernel InitialiseSnow
#pragma kernel UpdateVelocities
#pragma kernel Update
#pragma kernel UpdateCells
#pragma kernel ClampVelocity

#define maxFillGrade 1.0
#define compressionThreshold 100
#define frictionThreshold 1


//make sure all structs have a size that is a multiple of 16 bytes to ensure correct reading and writing
struct SnowCell
{
	float fillGrade;
	bool isColliding;
	float3 worldPosition;
	float3 velocity;
};

//because hlsl doesn't allow atomic operations for floats, we simply store (atomically) all float operations done on an element in an array
//once all float operations have been done, we can go through the array and apply them in order, thus ensuring an atomic add
//this means we need an additional dispatch call, but (according to nvidia) dispatch calls have negligible hw overhead and small sw overhead
struct AtomicStorage
{
	uint length;
	float values[63];
	uint velocityLength;
	float3 velocities[63];
	float2 padding;
};

struct SphereCollider
{
	float3 position;
	float3 velocity;
	float radius;
	float padding;
};

struct PlaneCollider
{
	float3 position;
	float3 normal;
	float2 padding;
};


RWStructuredBuffer<SnowCell> _Cells;
RWStructuredBuffer<AtomicStorage> _AtomicStorage;
RWStructuredBuffer<SphereCollider> _Colliders;
RWStructuredBuffer<PlaneCollider> _PlaneColliders;

int _Width;
int _Height;
int _FullWidth;
int _FullHeight;
int _FullLength;
int _NumColliders;
int _NumPlaneColliders;
float _DeltaTime;
float _Gravity;
float _CellSize;
float4 _OriginIndex;
float4 _GridOrigin;


bool isColliding(SphereCollider collider, float3 position)
{
	return (length(position - collider.position) <= collider.radius);
}

bool isCollidingHalfPlane(float3 planePoint, float3 planeNormal, float3 position)
{
    float3 vecToPoint = position - planePoint;
    return (dot(vecToPoint, planeNormal) <= 0);
}

float3 colliderNormalSphere(float3 colliderPosition, float3 position)
{
	return normalize(position - colliderPosition);
}

float3 DoSphereCollision (float3 position, float3 velocity, int index)
{
	float3 vel = velocity;

	for (int i = 0; i < _NumColliders; ++i) 
	{
		
		SphereCollider collider = _Colliders[i];

		if(isColliding(collider, position))
		{
			
			float3 vRel = vel -collider.velocity;
			float3 normal;
			normal = colliderNormalSphere(collider.position, position);
			float vn = dot(vRel, normal);	

			if (vn < 0) 
			{ //Bodies are not separating and a collision must be applied
				float3 vt = vRel - normal * vn;
				float magVt = length(vt);
				
				if (magVt <= -frictionThreshold * vn)
				{ // tangential velocity not enough to overcome force of friction

					vRel = float3(0, 0, 0);
				}
				else
				{
					//overcame collider.coeffFriction
					vRel = float3(0, 0, 0); 
					//vRel = (1 + frictionThreshold * vn / magVt) * vt;
				}
			}

			vel = vRel + collider.velocity;
			_Cells[index].isColliding = true;
		}
	}
	return vel;
}

bool isInBounds(int3 index)
{
	if (index.y < 0)
		return false;
	if (index.x < 0)
		return false;
	if (index.z < 0)
		return false;
	if (index.x > _FullWidth - 1)
		return false;
	if (index.y > _FullHeight - 1)
		return false;
	if (index.z > _FullLength - 1)
		return false;

	return true;
}

//move material to surrounding cells because target cell is full
void handleCellCollision(int3 index, int idx, int oldNearest)
{

	uint origIndex = 0;

	float3 velocity = _Cells[idx].velocity;

	int indices[27];
	int count = 0;
	
	for(int x = -1; x < 2; x++)
	{
		for(int y = -1; y < 2; y++)
		{
			for(int z = -1; z < 2; z++)
			{

				int3 newNearest = index + int3(x, y, z);

				if (!isInBounds(newNearest))
					continue;

				int nearestIdx = newNearest.x + (_FullWidth * newNearest.y) + (_FullHeight * _FullWidth * newNearest.z);
				
				if(nearestIdx == idx || nearestIdx == oldNearest || _Cells[nearestIdx].isColliding)
					continue;

				float3 direction = _Cells[nearestIdx].worldPosition - _Cells[idx].worldPosition;

				//if target cell is not in general direction of velocity we don't move material
				if (dot(direction, _Cells[idx].velocity) <= 0)
					continue;

				if (_Cells[nearestIdx].fillGrade < maxFillGrade)
				{
					indices[count] = nearestIdx;
					count++;					
				}
			}
		}
	}

	float mass = _Cells[idx].fillGrade / count;

	for(int i = 0; i < count; i++)
	{

		int curIndex = indices[i];

		float capacity = maxFillGrade - _Cells[curIndex].fillGrade;
		float massChange = capacity * length(_Cells[idx].velocity) *  _DeltaTime;

		if (_Cells[curIndex].fillGrade + massChange > maxFillGrade)
			massChange = maxFillGrade - _Cells[curIndex].fillGrade;

		if(mass - massChange < 0)
			massChange = mass;

		if(massChange > 0)
		{
			InterlockedAdd(_AtomicStorage[idx].length, 1, origIndex);
			_AtomicStorage[idx].values[origIndex] = -massChange;

			InterlockedAdd(_AtomicStorage[curIndex].length, 1, origIndex);
			_AtomicStorage[curIndex].values[origIndex] = massChange;
		}

	}
}

float _Radius;
float3 _Position;
float _FillGrade;
float3 _Velocity;

[numthreads(8,8,8)]
void InitialiseSnow (uint3 id : SV_DispatchThreadID)
{
	uint3 index = id;
	int idx = index.x + (_FullWidth * index.y) + (_FullHeight * _FullWidth * index.z);

	if((length(_Cells[idx].worldPosition - _Position) <= _Radius))
	{
		_Cells[idx].fillGrade = 0.9;
		_Cells[idx].velocity = float3(0,0,0);
	}
}


[numthreads(8,8,8)]
void InitialiseGrid (uint3 id : SV_DispatchThreadID)
{
	uint3 index = id;
	int idx = index.x + (_FullWidth * index.y) + (_FullHeight * _FullWidth * index.z);

	_Cells[idx].fillGrade = 0;

	_Cells[idx].velocity = float3(0,0,0);

	_Cells[idx].worldPosition = float3(id.x, id.y, id.z) * _CellSize;

	_Cells[idx].isColliding = false;

	_AtomicStorage[idx].length = 0;
	_AtomicStorage[idx].velocityLength = 0;
}


[numthreads(8,8,8)]
void UpdateVelocities (uint3 id : SV_DispatchThreadID)
{
	int idx = id.x + (_FullWidth * id.y) + (_FullHeight * _FullWidth * id.z);
	_Cells[idx].isColliding = false;

	for (int i = 0; i < _NumColliders; ++i) 
	{	
		SphereCollider collider = _Colliders[i];

		if(isColliding(collider, _Cells[idx].worldPosition))
		{
			_Cells[idx].isColliding = true;
			break;
		}		
	}


	if (_Cells[idx].fillGrade > 0)
	{
		_Cells[idx].velocity += float3(0, -_Gravity, 0) * _DeltaTime * (1/_Cells[idx].fillGrade);

		_Cells[idx].velocity = DoSphereCollision(_Cells[idx].worldPosition, _Cells[idx].velocity, idx);


		int3 nearestIndex = (int3)id + normalize(_Cells[idx].velocity);

		if (!isInBounds(nearestIndex))
		{
			_Cells[idx].velocity = float3(0, 0, 0);
		}
	}
	else
	{
		_Cells[idx].velocity = float3(0, 0, 0);
	}

}

[numthreads(8,8,8)]
void ClampVelocity(uint3 id : SV_DispatchThreadID)
{
	
	int idx = id.x + (_FullWidth * id.y) + (_FullHeight * _FullWidth * id.z);


	if(length(_Cells[idx].velocity) == 0)
		return;

	int3 nearestIndex = (int3)id + normalize(_Cells[idx].velocity);

	if (!isInBounds(nearestIndex))
		return;

	int nearest = nearestIndex.x + (_FullWidth * nearestIndex.y) + (_FullHeight * _FullWidth * nearestIndex.z);

	float fillGrade = _Cells[idx].fillGrade;
	float nearestFillGrade = _Cells[nearest].fillGrade;
/*
	uint origIndex = 0;

	//adjust cells velocity if other cell is already densely packed
	if (_Cells[nearest].fillGrade >= maxFillGrade && length(_Cells[nearest].velocity) < length(_Cells[idx].velocity))
	{
		InterlockedAdd(_AtomicStorage[nearest].velocityLength, 1, origIndex);
		_AtomicStorage[idx].velocities[origIndex] = normalize(_Cells[idx].velocity) * length(_Cells[nearest].velocity) - _Cells[idx].velocity;
	}*/

	uint origIndex = 0;
	float3 vel = float3(0, 0, 0);

	
	//velocity of cell is affected by velocity of neighbouring cells
	for (int x = -1; x < 2; x++)
	{
		for (int y = -1; y < 2; y++)
		{
			for (int z = -1; z < 2; z++)
			{

				int3 nearest = id + int3(x, y, z);

				if (!isInBounds(nearest))
					continue;

				int nearestIdx = nearest.x + (_FullWidth * nearest.y) + (_FullHeight * _FullWidth * nearest.z);
				
				if(nearestIdx == idx)
					continue;

				vel += _Cells[nearestIdx].velocity * _Cells[nearestIdx].fillGrade * _DeltaTime;
			}
		}
	}

	InterlockedAdd(_AtomicStorage[idx].velocityLength, 1, origIndex);
	_AtomicStorage[idx].velocities[origIndex] = vel;
}

[numthreads(8,8,8)]
void Update (uint3 id : SV_DispatchThreadID)
{
	int idx = id.x + (_FullWidth * id.y) + (_FullHeight * _FullWidth * id.z);

	for(int j = 0; j < _AtomicStorage[idx].velocityLength; j++)
	{
		_Cells[idx].velocity += _AtomicStorage[idx].velocities[j];
	}

	_AtomicStorage[idx].velocityLength = 0;

	if(length(_Cells[idx].velocity) == 0)
		return;

	int3 nearestIndex = (int3)id + normalize(_Cells[idx].velocity);

	if (!isInBounds(nearestIndex))
		return;

	int nearest = nearestIndex.x + (_FullWidth * nearestIndex.y) + (_FullHeight * _FullWidth * nearestIndex.z);

	uint origIndex = 0;

	float3 tempVelocity = _Cells[idx].velocity;
/*
	if (_Cells[nearest].fillGrade >= maxFillGrade && length(_Cells[nearest].velocity) < length(_Cells[idx].velocity))
	{
		InterlockedAdd(_AtomicStorage[nearest].velocityLength, 1, origIndex);
		_AtomicStorage[idx].velocities[origIndex] = normalize(_Cells[idx].velocity) * length(_Cells[nearest].velocity) - _Cells[idx].velocity;

		tempVelocity = normalize(_Cells[idx].velocity) * length(_Cells[nearest].velocity);
	}*/



	float fillGrade = _Cells[idx].fillGrade;
	float nearestFillGrade = _Cells[nearest].fillGrade;

	//mass moved depends on space in the target cell
	float capacity = maxFillGrade - nearestFillGrade;
	float massChange = fillGrade * length(tempVelocity) *  _DeltaTime;
	

	if (nearestFillGrade + massChange > maxFillGrade)
		massChange = maxFillGrade - nearestFillGrade;

	if(fillGrade - massChange < 0)
		massChange = fillGrade;


	//only move material if force is strong enough to compress snow; this scales with mass of other cell => the more compressed snow is the harder it is to compress it further
	if (length(tempVelocity) > compressionThreshold * nearestFillGrade)
	{
		InterlockedAdd(_AtomicStorage[idx].length, 1, origIndex);
		_AtomicStorage[idx].values[origIndex] = -massChange;

		InterlockedAdd(_AtomicStorage[nearest].length, 1, origIndex);
		_AtomicStorage[nearest].values[origIndex] = massChange;
	}
	else//otherwise, we move material to the surrounding cells as the snow gets pressed to the side
	{
		handleCellCollision(id, idx, nearest);
	}

	//InterlockedAdd(_AtomicStorage[nearest].velocityLength, 1, origIndex);
	//_AtomicStorage[nearest].velocities[origIndex] = _Cells[idx].velocity * (1 - nearestFillGrade) * fillGrade * _DeltaTime;

	InterlockedAdd(_AtomicStorage[idx].velocityLength, 1, origIndex);
	_AtomicStorage[idx].velocities[origIndex] = nearestFillGrade * _Cells[idx].velocity * -1;

}

[numthreads(8, 8, 8)]
void UpdateCells(uint3 id : SV_DispatchThreadID)
{
	int idx = id.x + (_FullWidth * id.y) + (_FullHeight * _FullWidth * id.z);

	for(int j = 0; j < _AtomicStorage[idx].velocityLength; j++)
	{
		_Cells[idx].velocity += _AtomicStorage[idx].velocities[j];
	}

	for(int i = 0; i < _AtomicStorage[idx].length; i++)
	{
		_Cells[idx].fillGrade += _AtomicStorage[idx].values[i];
	}

	if(_Cells[idx].fillGrade <= 0)
		_Cells[idx].velocity = float3(0,0,0);
	else if (length(_Cells[idx].velocity) > 10000000) //seems like the gpu driver crashes when we run out of bounds for these floats
		_Cells[idx].velocity = normalize(_Cells[idx].velocity) * 10000000;



	_AtomicStorage[idx].length = 0;
	_AtomicStorage[idx].velocityLength = 0;
}