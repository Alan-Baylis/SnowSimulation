// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel Update
#pragma kernel UpdateCells
#pragma kernel DoSphereCollision


#include "Assets\Snow.cginc"
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture


struct SnowCell
{
	float fillGrade;
	float3 worldPosition;
	float3 velocity;
};

RWStructuredBuffer<SnowCell> _Cells;
RWStructuredBuffer<SnowCell> _OutputCells;

int _BottomExists;
int _Width;
int _Height;
int _FullWidth;
int _FullHeight;
int _FrameCounter;
float _DeltaTime;
float _Gravity;
float _CellSize;
float4 _OriginIndex;

SnowParticle p;




[numthreads(8,8,8)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	uint3 index = id + _OriginIndex.xyz;
	uint idx = index.x + _FullWidth * (index.y + _FullHeight * index.z);

	if(_Cells[idx].fillGrade == 0)
	{
		_Cells[idx].velocity = float3(0,0,0);
		return;
	}

	_Cells[idx].velocity += float3(0,-1,0) * _Cells[idx].fillGrade * (_Gravity/(_DeltaTime * _DeltaTime));
	_OutputCells[idx].velocity = _Cells[idx].velocity;
}


[numthreads(8,8,8)]
void Update (uint3 id : SV_DispatchThreadID)
{
	uint3 index = id + _OriginIndex.xyz;
	uint idx = index.x + _FullWidth * (index.y + _FullHeight * index.z);

	float3 movementVector = _Cells[idx].velocity * _DeltaTime;
	float3 velocityNorm = _Cells[idx].velocity;

	float3 finalIndex = id + movementVector;	

	int3 nearestIndex = index + normalize(velocityNorm);
	int nearest = nearestIndex.x + _FullWidth * (nearestIndex.y + _FullHeight * nearestIndex.z);

	float fillGrade = _Cells[idx].fillGrade;
	float nearestFillGrade = _Cells[nearest].fillGrade;

	AllMemoryBarrierWithGroupSync();

	if(fillGrade <= 0)
		return;

	if(nearestIndex.y < 0 || nearestIndex.y > _FullHeight -1)
		return;

	if(idx == nearest)
		return;

	if(nearestFillGrade < 0.8)
	{
		float capacity = 0.8 - nearestFillGrade;
		float massChange = (sqrt(capacity)) * _DeltaTime * _Gravity;

		if(nearestFillGrade + massChange > 0.8)
			massChange = 0.8 - nearestFillGrade;

		if(fillGrade - massChange < 0)
			massChange = fillGrade;

		_Cells[idx].fillGrade -= massChange;
		_Cells[nearest].fillGrade += massChange;

		_Cells[nearest].velocity += _Cells[idx].velocity *  (1 - _Cells[nearest].fillGrade);
		_Cells[idx].velocity -= _Cells[idx].velocity *  (1 - _Cells[nearest].fillGrade);
	}
}

[numthreads(8,8,8)]
void UpdateCells (uint3 id : SV_DispatchThreadID)
{
	uint3 index = id + _OriginIndex.xyz;
	uint idx = index.x + _FullWidth * (index.y + _FullHeight * index.z);
	
	_Cells[idx] = _OutputCells[idx];
}

float4 _SphereCenter;
float _SphereRadius;

[numthreads(8,8,8)]
void DoSphereCollision (uint3 id : SV_DispatchThreadID)
{
	uint3 index = id + _OriginIndex.xyz;
	uint idx = index.x + _FullWidth * (index.y + _FullHeight * index.z);
	
	if(_Cells[idx].fillGrade == 0)
		return;

	float3 velocityNorm = _Cells[idx].velocity;
	normalize(velocityNorm);

	int3 nearestIndex = int3(0,0,0);
	
/*
	if(abs(velocityNorm.x) > 0.5)
		nearestIndex.x = sign(velocityNorm.x);
	if(abs(velocityNorm.y) > 0.5)
		nearestIndex.y = sign(velocityNorm.y);
	if(abs(velocityNorm.z) > 0.5)
		nearestIndex.z = sign(velocityNorm.z);*/

	nearestIndex = index + normalize(velocityNorm);

	if (nearestIndex.y < 0 || nearestIndex.y > _FullHeight -1)
		return;

	int nearest = index.x + _FullWidth * ((index.y-1) + _FullHeight * index.z);
	
	float3 cellPosition = _Cells[idx].worldPosition + float3(_CellSize, _CellSize, _CellSize)/2;
	float3 nearestCellPosition = _Cells[nearest].worldPosition + float3(_CellSize, _CellSize, _CellSize)/2;
	float distance = length(cellPosition - _SphereCenter.xyz);

	if(distance < _SphereRadius)
	{
		_Cells[idx].velocity = float3(0,1,0); //normalize(cellPosition - _SphereCenter.xyz) * 100;
		_OutputCells[idx].velocity = _Cells[idx].velocity;

		/*
		_OutputCells[idx].fillGrade = 0;
		_Cells[idx].fillGrade = 0;*/
	}
}