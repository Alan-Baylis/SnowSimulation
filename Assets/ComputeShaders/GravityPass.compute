// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#pragma kernel Update

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

struct SnowCell
{
	float fillGrade;
	float3 worldPosition;
	float3 velocity;
};

RWStructuredBuffer<SnowCell> _Cells;
RWStructuredBuffer<SnowCell> _BottomBuffer;

int _BottomExists;
int _Width;
int _Height;
float _DeltaTime;
float _Gravity;

void UpdateBuffer(RWStructuredBuffer<SnowCell> _buffer, int _index, int _origIndex)
{
	if(_buffer[_index].fillGrade < 0.8)
	{
		float capacity = 0.8 - _buffer[_index].fillGrade;
		float massChange = (sqrt(capacity)) * _DeltaTime * _Gravity;

		if(_buffer[_index].fillGrade + massChange > 0.8)
			massChange = 0.8 - _buffer[_index].fillGrade;

		if(_Cells[_origIndex].fillGrade - massChange < 0)
			massChange = _Cells[_origIndex].fillGrade;

		_Cells[_origIndex].fillGrade -= massChange;
		_buffer[_index].fillGrade += massChange;

		_buffer[_index].velocity += _Cells[_origIndex].velocity *  (1 - _buffer[_index].fillGrade);
	}
}

[numthreads(8,8,8)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	uint idx = id.x + _Width * (id.y + _Height * id.z);

	if(_Cells[idx].fillGrade == 0)
	{
		_Cells[idx].velocity = float3(0,0,0);
		return;
	}

	_Cells[idx].velocity += float3(0,-1,0) * _Cells[idx].fillGrade * (_Gravity/(_DeltaTime * _DeltaTime));
}

[numthreads(8,8,8)]
void Update (uint3 id : SV_DispatchThreadID)
{
	uint idx = id.x + _Width * (id.y + _Height * id.z);

	if(_Cells[idx].fillGrade == 0 || length(_Cells[idx].velocity) == 0)
		return;
	
	float3 movementVector = _Cells[idx].velocity * _DeltaTime;
	float3 velocityNorm = _Cells[idx].velocity;
	normalize(velocityNorm);

	float3 finalIndex = id + movementVector;	

	int3 nearestIndex = int3(0,0,0);

	
	if(abs(velocityNorm.x) > 0.5)
		nearestIndex.x = sign(velocityNorm.x);
	if(abs(velocityNorm.y) > 0.5)
		nearestIndex.y = sign(velocityNorm.y);
	if(abs(velocityNorm.z) > 0.5)
		nearestIndex.z = sign(velocityNorm.z);

	
	nearestIndex = id + nearestIndex;

	if(!any(nearestIndex - id))
		return;

	int nearest = nearestIndex.x + _Width * (nearestIndex.y + _Height * nearestIndex.z);

	if(_Cells[nearest].fillGrade >= 0.8)
		return;

	if(nearestIndex.y < 0)
	{
		if(_BottomExists == 1)
		{
			int _bottom = nearestIndex.x + _Width * ((_Height -1) + _Height * nearestIndex.z);
			UpdateBuffer(_BottomBuffer, _bottom, idx);
			return;
		}
		else
			return;
	}

	if(nearestIndex.y > _Height -1)
		return;
		


	int3 finalCell = (int3) finalIndex;
	uint targetCellIdx = finalCell.x + _Width * (finalCell.y + _Height * finalCell.z);

	UpdateBuffer(_Cells, nearest, idx);
	
/*
	if(_Cells[nearest].fillGrade < 0.8)
	{
		float capacity = 0.8 - _Cells[nearest].fillGrade;
		float massChange = (sqrt(capacity)) * _DeltaTime * _Gravity;

		if(_Cells[nearest].fillGrade + massChange > 0.8)
			massChange = 0.8 - _Cells[nearest].fillGrade;

		if(_Cells[idx].fillGrade - massChange < 0)
			massChange = _Cells[idx].fillGrade;

		_Cells[idx].fillGrade -= massChange;
		_Cells[nearest].fillGrade += massChange;
	}*/
}
