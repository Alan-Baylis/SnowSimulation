// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel InitialiseGrid
#pragma kernel UpdateVelocities
#pragma kernel Update
#pragma kernel UpdateCells

#define maxFillGrade 0.9
#define compressionThreshold 1


//make sure all structs have a size that is a multiple of 16 bytes to ensure correct reading and writing
struct SnowCell
{
	float fillGrade;
	bool isColliding;
	float3 worldPosition;
	float3 velocity;
};

//because hlsl doesn't allow atomic operations for floats, we simply store (atomically) all float operations done on an element in an array
//once all float operations have been done, we can go through the array and apply them in order, thus ensuring an atomic add
//this means we need an additional dispatch call, but (according to nvidia) dispatch calls have negligible hw overhead and small sw overhead
struct AtomicStorage
{
	uint length;
	float values[63];
	uint velocityLength;
	float3 velocities[63];
	float2 padding;
};

struct SphereCollider
{
	float3 position;
	float3 velocity;
	float radius;
	float padding;
};


RWStructuredBuffer<SnowCell> _Cells;
RWStructuredBuffer<AtomicStorage> _AtomicStorage;
RWStructuredBuffer<SphereCollider> _Colliders;

int _Width;
int _Height;
int _FullWidth;
int _FullHeight;
int _FullLength;
int _NumColliders;
float _DeltaTime;
float _Gravity;
float _CellSize;
float4 _OriginIndex;
float4 _GridOrigin;


bool isColliding(SphereCollider collider, float3 position)
{
	return (length(position - collider.position) <= collider.radius);
}

float3 colliderNormalSphere(float3 colliderPosition, float3 position)
{
	return normalize(position - colliderPosition);
}

float3 DoSphereCollision (float3 position, float3 velocity, int index)
{
	float3 vel = velocity;

	for (int i = 0; i < _NumColliders; ++i) 
	{
		
		SphereCollider collider = _Colliders[i];

		if(isColliding(collider, position))
		{
			
			float3 vRel = vel -collider.velocity;
			float3 normal;
			normal = colliderNormalSphere(collider.position, position);
			float vn = dot(vRel, normal);	

			if (vn < 0) 
			{ //Bodies are not separating and a collision must be applied
				float3 vt = vRel - normal * vn;
				float magVt = length(vt);
				
				if (magVt <= -0.1 * vn) 
				{ // tangential velocity not enough to overcome force of friction

					vRel = float3(0, 0, 0);
				}
				else
				{
					//overcame collider.coeffFriction
					//vRel = float3(0, 0, 0); 
					vRel = (1 + 0.1 * vn / magVt) * vt;
				}
			}

			vel = vRel + collider.velocity;
			_Cells[index].isColliding = true;
		}
	}
	return vel;
}

bool isInBounds(int3 index)
{
	if(index.y < 0)
		return false;
	if(index.x < 0)
		return false;
	if(index.z < 0)
		return false;
	if(index.x > _FullWidth)
		return false;
	if(index.y > _FullHeight)
		return false;
	if(index.z > _FullLength)
		return false;

	return true;

}


void handleCellCollision(int3 index, int idx, int oldNearest)
{

	uint origIndex = 0;

	float3 velocity = _Cells[idx].velocity;

	int indices[27];
	int count = 0;
	
	for(int x = -1; x < 2; x++)
	{
		for(int y = -1; y < 2; y++)
		{
			for(int z = -1; z < 2; z++)
			{

				int3 newNearest = index + int3(x, y, z);

				if(newNearest.y < 0 || newNearest.x < 0 || newNearest.z < 0)
					continue;

				int nearestIdx = newNearest.x + (_FullWidth * newNearest.y) + (_FullHeight * _FullWidth * newNearest.z);
				
				if(nearestIdx == idx || nearestIdx == oldNearest)
					continue;

				float3 direction = _Cells[nearestIdx].worldPosition - _Cells[idx].worldPosition;

				if (dot(direction, _Cells[idx].velocity) <= 0)
					continue;

				if (_Cells[nearestIdx].fillGrade < maxFillGrade && !_Cells[nearestIdx].isColliding)
				{

					indices[count] = nearestIdx;
					count++;					
				}
			}
		}
	}

	float mass = _Cells[idx].fillGrade / count;

	for(int i = 0; i < count; i++)
	{

		int curIndex = indices[i];

		float capacity = maxFillGrade - _Cells[curIndex].fillGrade;
		float massChange = capacity * length(_Cells[idx].velocity) *  _DeltaTime;

		if (_Cells[curIndex].fillGrade + massChange > maxFillGrade)
			massChange = maxFillGrade - _Cells[curIndex].fillGrade;

		if(mass - massChange < 0)
			massChange = mass;

		if (length(_Cells[idx].velocity) * (1 - _Cells[curIndex].fillGrade) > compressionThreshold)
		{
			InterlockedAdd(_AtomicStorage[idx].length, 1, origIndex);
			_AtomicStorage[idx].values[origIndex] = -massChange;

			InterlockedAdd(_AtomicStorage[curIndex].length, 1, origIndex);
			_AtomicStorage[curIndex].values[origIndex] = massChange;
		}	
	}
}


[numthreads(8,8,8)]
void InitialiseGrid (uint3 id : SV_DispatchThreadID)
{
	uint3 index = id;
	int idx = index.x + (_FullWidth * index.y) + (_FullHeight * _FullWidth * index.z);


	if(id.y < 64 && id.y > 48 && id.x < 90 && id.z < 90 && id.x > 32 && id.z > 32)
		_Cells[idx].fillGrade = 0.2;
	else 
		_Cells[idx].fillGrade = 0;

	_Cells[idx].velocity = float3(0,0,0);

	_Cells[idx].worldPosition = float3(id.x, id.y, id.z) * _CellSize;

	_Cells[idx].isColliding = false;

	_AtomicStorage[idx].length = 0;
	_AtomicStorage[idx].velocityLength = 0;
}


[numthreads(8,8,8)]
void UpdateVelocities (uint3 id : SV_DispatchThreadID)
{
	int idx = id.x + (_FullWidth * id.y) + (_FullHeight * _FullWidth * id.z);
	_Cells[idx].isColliding = false;	


	if (_Cells[idx].fillGrade > 0)
	{
		_Cells[idx].velocity += float3(0, -_Gravity, 0) * (1 / _Cells[idx].fillGrade) * _DeltaTime;

		_Cells[idx].velocity = DoSphereCollision(_Cells[idx].worldPosition, _Cells[idx].velocity, idx);

		float3 vel = float3(0,0,0);

		for(int x = -1; x < 2; x++)
		{
			for(int y = -1; y < 2; y++)
			{
				for(int z = -1; z < 2; z++)
				{

					int3 nearest = id + int3(x, y, z);

					if(!isInBounds(nearest))
						continue;

					int nearestIdx = nearest.x + (_FullWidth * nearest.y) + (_FullHeight * _FullWidth * nearest.z);
				
					if(nearestIdx == idx)
						continue;

					vel += _Cells[nearestIdx].velocity *  _Cells[nearestIdx].fillGrade;
				}
			}
		}

		uint origIndex;

		//InterlockedAdd(_AtomicStorage[idx].velocityLength, 1, origIndex);
		//_AtomicStorage[idx].velocities[origIndex] = vel;
		
	}
}

[numthreads(8,8,8)]
void Update (uint3 id : SV_DispatchThreadID)
{
	int idx = id.x + (_FullWidth * id.y) + (_FullHeight * _FullWidth * id.z);

	if(length(_Cells[idx].velocity) == 0)
		return;

	int3 nearestIndex = (int3)id + normalize(_Cells[idx].velocity);

	int nearest = nearestIndex.x + (_FullWidth * nearestIndex.y) + (_FullHeight * _FullWidth * nearestIndex.z);

	if(nearestIndex.y < 0 || nearestIndex.x < 0 || nearestIndex.z < 0)
		return;

	if(nearest < 0 || nearest > (_FullHeight * _FullHeight * _FullHeight) - 1 || nearest == idx)
		return;

	float fillGrade = _Cells[idx].fillGrade;
	float nearestFillGrade = _Cells[nearest].fillGrade;

	//only move material if there is room in the next cell
	if (nearestFillGrade < maxFillGrade)
	{
		float capacity = maxFillGrade - nearestFillGrade;
		float massChange = capacity * length(_Cells[idx].velocity) *  _DeltaTime;
	
		if (nearestFillGrade + massChange > maxFillGrade)
			massChange = maxFillGrade - nearestFillGrade;

		if(fillGrade - massChange < 0)
			massChange = fillGrade;

		uint origIndex = 0;

		//only move material if force is strong enough to compress snow
		if (length(_Cells[idx].velocity) * (1 - nearestFillGrade) > compressionThreshold || nearestFillGrade == 0)
		{
			InterlockedAdd(_AtomicStorage[idx].length, 1, origIndex);
			_AtomicStorage[idx].values[origIndex] = -massChange;

			InterlockedAdd(_AtomicStorage[nearest].length, 1, origIndex);
			_AtomicStorage[nearest].values[origIndex] = massChange;
		}
		else //otherwise, we move material to the surrounding cells as the snow gets pressed to the side
		{
			handleCellCollision(id, idx, nearest);
		}
		
		
		InterlockedAdd(_AtomicStorage[idx].velocityLength, 1, origIndex);
		_AtomicStorage[idx].velocities[origIndex] = nearestFillGrade * _Cells[idx].velocity * -1; // (maxFillGrade - nearestFillGrade) * _Cells[idx].velocity * _DeltaTime * -1;

		InterlockedAdd(_AtomicStorage[nearest].velocityLength, 1, origIndex);
		_AtomicStorage[nearest].velocities[origIndex] = (maxFillGrade - nearestFillGrade) * _Cells[idx].velocity * _DeltaTime;

	}
	else //otherwise, we move material to the surrounding cells as the snow gets pressed to the side
	{
		handleCellCollision(id, idx, nearest);
	}
}

[numthreads(8, 8, 8)]
void UpdateCells(uint3 id : SV_DispatchThreadID)
{
	int idx = id.x + (_FullWidth * id.y) + (_FullHeight * _FullWidth * id.z);

	int length = _AtomicStorage[idx].length;

	for(int i = 0; i < length; i++)
	{
		_Cells[idx].fillGrade += _AtomicStorage[idx].values[i];
	}
	
	for(int i = 0; i < _AtomicStorage[idx].velocityLength; i++)
	{
		_Cells[idx].velocity += _AtomicStorage[idx].velocities[i];
	}

	if(_Cells[idx].fillGrade <= 0)
		_Cells[idx].velocity = float3(0,0,0);

	_AtomicStorage[idx].length = 0;
	_AtomicStorage[idx].velocityLength = 0;
}